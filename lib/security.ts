/**
 * Security Utilities
 *
 * Provides input sanitization and security functions to prevent:
 * - Formula injection in Google Sheets
 * - XSS (Cross-Site Scripting) attacks
 * - Data corruption
 * - Information disclosure
 * - Timing attacks on token validation
 *
 * References:
 * - OWASP Input Validation Cheat Sheet
 * - Google Sheets Formula Injection Prevention
 * - OWASP Authentication Cheat Sheet (Timing Attack Prevention)
 */

import crypto from "crypto";

/**
 * Sanitize input for Google Sheets storage
 *
 * Prevents formula injection by escaping dangerous characters that could
 * be interpreted as formulas by spreadsheet applications.
 *
 * Dangerous prefixes:
 * - = (formula)
 * - + (formula)
 * - - (formula)
 * - @ (formula)
 * - \t (tab - can cause issues)
 * - \r (carriage return - can cause issues)
 *
 * Implementation:
 * If a string starts with any dangerous character, prefix it with a single
 * quote (') to force Google Sheets to treat it as literal text.
 *
 * @param value - String to sanitize
 * @returns Sanitized string safe for Google Sheets storage
 *
 * @example
 * sanitizeForSheets("=1+1") // Returns "'=1+1"
 * sanitizeForSheets("@SUM(A1:A10)") // Returns "'@SUM(A1:A10)"
 * sanitizeForSheets("Normal Name") // Returns "Normal Name"
 */
export function sanitizeForSheets(value: string): string {
  // Check if value is null/undefined
  if (!value || typeof value !== "string") {
    return "";
  }

  // Trim the value first to check actual first character
  const trimmed = value.trim();

  // Check if starts with dangerous characters
  if (/^[=+\-@\t\r]/.test(trimmed)) {
    // Prefix with single quote to treat as literal text
    return `'${trimmed}`;
  }

  // Return trimmed value if safe
  return trimmed;
}

/**
 * Sanitize input for display
 *
 * Removes potentially dangerous content before displaying to users.
 * React automatically escapes HTML, but this provides additional protection.
 *
 * Security measures:
 * - Strips HTML tags (defense in depth with React's auto-escaping)
 * - Removes control characters
 * - Normalizes whitespace
 *
 * @param value - String to sanitize for display
 * @returns Sanitized string safe for display
 *
 * @example
 * sanitizeForDisplay("<script>alert('xss')</script>") // Returns "scriptalert('xss')/script"
 * sanitizeForDisplay("Name\u0000WithNull") // Returns "NameWithNull"
 */
export function sanitizeForDisplay(value: string): string {
  // Check if value is null/undefined
  if (!value || typeof value !== "string") {
    return "";
  }

  let sanitized = value;

  // Remove HTML tags (basic sanitization - React handles most XSS)
  // This is defense in depth, not primary XSS protection
  sanitized = sanitized.replace(/<[^>]*>/g, "");

  // Remove control characters (except newlines and tabs which might be legitimate)
  sanitized = sanitized.replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F]/g, "");

  // Normalize whitespace
  sanitized = sanitized.replace(/\s+/g, " ").trim();

  return sanitized;
}

/**
 * Validate and sanitize edit token
 *
 * Ensures token meets security requirements before processing.
 * Tokens are 64-character hexadecimal strings generated by crypto.randomBytes(32).
 *
 * Security validations:
 * - Type checking (must be string)
 * - Length validation (exactly 64 characters)
 * - Character validation (hexadecimal only: 0-9, a-f)
 * - Format protection (prevents path traversal, XSS, etc.)
 *
 * @param token - Token to validate
 * @returns Sanitized token or null if invalid
 *
 * @example
 * validateToken("a3f5b8c2d1e9f7a4...") // Returns the token if 64 hex chars
 * validateToken("../../../etc/passwd") // Returns null
 * validateToken("<script>alert('xss')</script>") // Returns null
 * validateToken("abc123") // Returns null (too short)
 */
export function validateToken(token: string | null | undefined): string | null {
  // Check if token exists
  if (!token || typeof token !== "string") {
    return null;
  }

  // Trim token
  const trimmed = token.trim();

  // Check length (must be exactly 64 characters for crypto.randomBytes(32).toString('hex'))
  if (trimmed.length !== 64) {
    return null;
  }

  // Check characters (hexadecimal only: 0-9, a-f)
  if (!/^[a-f0-9]+$/.test(trimmed)) {
    return null;
  }

  return trimmed;
}

/**
 * Timing-safe token comparison
 *
 * Prevents timing attacks by using constant-time comparison.
 * Regular string comparison (===) can leak information about token correctness
 * through timing differences, allowing attackers to brute-force tokens.
 *
 * Security Requirements (OWASP):
 * - Uses crypto.timingSafeEqual() for constant-time comparison
 * - Comparison time is independent of token correctness
 * - Prevents timing-based brute force attacks
 *
 * Implementation notes:
 * - Both strings must be same length (checked before comparison)
 * - Converted to Buffers for timingSafeEqual
 * - Returns boolean, never throws
 *
 * @param providedToken - Token provided by user/client
 * @param storedToken - Token stored in database
 * @returns True if tokens match, false otherwise
 *
 * @example
 * const isValid = compareTokens(userToken, dbToken)
 * if (isValid) {
 *   // Grant access
 * }
 *
 * @see https://owasp.org/www-community/vulnerabilities/Timing_attack
 */
export function compareTokens(
  providedToken: string,
  storedToken: string
): boolean {
  // Type guards
  if (
    !providedToken ||
    !storedToken ||
    typeof providedToken !== "string" ||
    typeof storedToken !== "string"
  ) {
    return false;
  }

  // Length check (timingSafeEqual requires same length)
  // This doesn't leak timing information as length is not secret
  if (providedToken.length !== storedToken.length) {
    return false;
  }

  // Additional security: verify both tokens are valid format
  // This prevents timing attacks on malformed tokens
  if (providedToken.length !== 64 || storedToken.length !== 64) {
    return false;
  }

  try {
    // Constant-time comparison using Node.js crypto module
    // Time taken is independent of where strings differ
    return crypto.timingSafeEqual(
      Buffer.from(providedToken, "utf8"),
      Buffer.from(storedToken, "utf8")
    );
  } catch (error) {
    // timingSafeEqual can throw if buffers are different lengths
    // This should never happen due to checks above, but handle gracefully
    console.error("[Security] Token comparison error:", error);
    return false;
  }
}

/**
 * Security event logging utility
 *
 * Logs security-related events without exposing sensitive data.
 * Sanitizes all logged data to prevent information disclosure.
 *
 * Event types:
 * - validation_failed: Input validation failures
 * - invalid_token: Invalid token access attempts
 * - api_error: Google Sheets API errors
 * - suspicious_activity: Potential security threats
 *
 * @param event - Type of security event
 * @param details - Event details (will be sanitized)
 *
 * @example
 * logSecurityEvent('invalid_token', { action: 'editRSVP', token: 'abc123...' })
 */
export type SecurityEvent =
  | "validation_failed"
  | "invalid_token"
  | "api_error"
  | "suspicious_activity"
  | "rate_limit_exceeded";

interface LogEntry {
  event: SecurityEvent;
  timestamp: string;
  details: Record<string, unknown>;
}

export function logSecurityEvent(
  event: SecurityEvent,
  details: Record<string, unknown>
): void {
  // Sanitize details to prevent information disclosure
  const sanitizedDetails = sanitizeLogDetails(details);

  const logEntry: LogEntry = {
    event,
    timestamp: new Date().toISOString(),
    details: sanitizedDetails,
  };

  // In production, this would send to a logging service (Sentry, Datadog, etc.)
  // For now, use console.warn with structured JSON format
  console.warn("[Security Event]", JSON.stringify(logEntry));

  // Future: Send to Sentry or other monitoring service
  // if (process.env.SENTRY_DSN) {
  //   Sentry.captureMessage(`Security event: ${event}`, {
  //     level: 'warning',
  //     extra: logEntry
  //   })
  // }
}

/**
 * Sanitize log details to prevent information disclosure
 *
 * Removes or hashes sensitive data before logging:
 * - Tokens: Log only first 8 characters
 * - Names: Don't log (PII)
 * - Email: Don't log (PII)
 * - Full error messages: Sanitize stack traces
 *
 * @param details - Raw log details
 * @returns Sanitized log details
 */
function sanitizeLogDetails(details: Record<string, unknown>): Record<string, unknown> {
  const sanitized = { ...details };

  // Sanitize token (only log first 8 chars)
  if ("token" in sanitized && typeof sanitized.token === "string") {
    sanitized.token = sanitized.token.substring(0, 8) + "...";
  }

  // Remove PII fields
  const piiFields = ["nama", "name", "email", "phone", "bilanganOrang"];
  piiFields.forEach((field) => {
    if (field in sanitized) {
      delete sanitized[field];
    }
  });

  // Sanitize error messages (remove stack traces)
  if ("error" in sanitized && typeof sanitized.error === "string") {
    // Only log first line of error (remove stack trace)
    sanitized.error = sanitized.error.split("\n")[0];
  }

  return sanitized;
}

/**
 * Safely parse and validate numeric input
 *
 * Prevents type confusion attacks by ensuring input is truly numeric
 * and within expected ranges.
 *
 * @param value - Value to parse
 * @param min - Minimum allowed value
 * @param max - Maximum allowed value
 * @returns Parsed number or null if invalid
 *
 * @example
 * safeParseInt("5", 1, 10) // Returns 5
 * safeParseInt("100", 1, 10) // Returns null (out of range)
 * safeParseInt("abc", 1, 10) // Returns null (not a number)
 */
export function safeParseInt(
  value: string | number | null | undefined,
  min?: number,
  max?: number
): number | null {
  // Handle null/undefined
  if (value === null || value === undefined) {
    return null;
  }

  // Parse if string
  const num = typeof value === "string" ? parseInt(value, 10) : value;

  // Check if valid number
  if (isNaN(num) || !isFinite(num)) {
    return null;
  }

  // Check if integer
  if (num !== Math.floor(num)) {
    return null;
  }

  // Check range if specified
  if (min !== undefined && num < min) {
    return null;
  }

  if (max !== undefined && num > max) {
    return null;
  }

  return num;
}
